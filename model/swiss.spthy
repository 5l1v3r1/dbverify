/* Implementation of Swiss-Knife protocol*/
/* By Jorge Toro */

/*
This protocol considers asymetric encryption,
as a secret long-term key x of the prover is
used. Afterwards, the verifier has to look-up
a mathcing pair (P, x) from their database. We
model this by using a symmetric encryption
scheme, hence x is the shared key. 
*/


theory swiss

begin

builtins: 	symmetric-encryption, asymmetric-encryption

functions: 	f/2, g/2, XOR/2

// -------------------- Protocol Rules -------------------- //
rule Verif1:
	  [ Fr(~n) ]
	--[ Start(~n) ]->
	  [ VerifState1(~n),
			Out(~n) ]

rule Prover1:
	  let a = f(x,<'hello', ~m>)
	  in
	  [ In(n),
			Fr(~m),
			!Shk($V, $P, x) ]
	--[ Start(~m),
			Action($P) ]->
	  [ Send($P, ~m),
			ProverState1($V, $P, n, ~m, a) ]

rule Verif2:		//fast phase starts
	  [ VerifState1(n),
			In(m),
			Fr(~c) ]
	--[ Send($V, ~c) ]->
	  [ VerifState2($V, n, m, ~c),
			Out(~c) ]

rule Prover2:
	  [ ProverState1(V, P, n, m, a),
			In(c),
			!Shk(V, P, x) ]
	--[ Action(P) ]->
	  [ Send(P, g(c, <a, XOR(a, x)>) ),
			ProverState2(V, P, n, m, c) ]

rule Verif3:			//fast phase ends
	  let a = f(x, <'hello', m>)
		  resp = g(c, <a, XOR(a,x)>)
	  in
	  [ VerifState2(V, n, m, c),
			!Shk(V, $P, x),
			Recv(V, resp ) ]
	-->
	  [ VerifState3(V, $P, n, m, c, resp) ]

rule Prover3:
	  [ ProverState2(V, P, n, m, c),
			!Shk(V, P, x) ]
	--[ Action(P) ]->
	  [ Send(P, <f(x, <c, P, n, m>), c> ),
			ProverState3(V, P, m) ]

rule Verif4:
	  [ VerifState3(V, P, n, m, c, resp),
			In( <f(x, <c, P, n, m>), c> ),
			!Shk(V, P, x) ]
	--[ DBSec(V, P, c, resp),
			End(n) ]->
	  [ Out( f(x, m) ) ]

rule Prover4:
	  [ ProverState3(V, P, m),
			!Shk(V, P, x),
			In(f(x, m)) ]
	--[ Action(P),
			End(m) ]->
	  [ ]

// -------------------- Sanity Check Lemmas ------------------ //
lemma complete_trace_exists:
	exists-trace
	"
	Ex V P n m c x #t1 #t2 #t3 #t4 #t5 #t6 #t7 #t8.
		
		//intial phase
		Start(n) @ t1 &
		Start(m) @ t2 &
		Action(P) @ t2 &

		//fast phase
		Send(V, c) @ t3 &
		Action(P) @ t4 &
		Recv(V, 
			g(c, <f(x, <'hello', m>), XOR(f(x, <'hello', m>), x)> ) ) @ t5 &		
		
		//verification
		Action(P) @ t6 &
		DBSec(V, P, c, 
			g(c, <f(x, <'hello', m>), XOR(f(x, <'hello', m>), x)> ) ) @ t7 &
		Action(P) @ t8 &

		t1 < t2 & t2 < t3 & t3 < t4 & 
		t4 < t5 & t5 < t6 & t6 < t7 & t7 < t8
	"
//GENERIC CODE AFTER THIS LINE
//comment out whatever not needed

// ------------- Key Generation Rules -------------------- //
rule AsymKey:
	[ Fr(~k) ]--[ Once($A) ]->[ !Ltk($A, ~k), !Pk($A, pk(~k)), Out(pk(~k)) ]

rule SymKey:
	[ Fr(~k) ]--[ Once(<$A, $B>) ]->[ !Shk($A, $B, ~k) ]


// ------------------ Corruption Rules -----------//
rule LtkReveal:
	[ !Ltk($A, k) ]--[ Corrupt($A) ]->[ !CorruptAgnt($A), Out(k) ]

rule ShkRevealA:
	[ !Shk($A, $B, k) ]--[ Corrupt($A) ]->[ !CorruptAgnt($A), Out(k) ]

rule ShkRevealB:
	[ !Shk($A, $B, k) ]--[ Corrupt($B) ]->[ !CorruptAgnt($B), Out(k) ]

// ---------- Adversary and Network Rules ------------------//
rule Adv:
	[ In(m), !CorruptAgnt($A) ]--[ Action($A) ]->[ Send($A, m) ]

rule Net:
	[ Send($A, m) ]--[ Recv($B, m) ]->[ Recv($B, m), Out(m) ]

// -------------------- Sanity Check ------------------ //

//Each run id is unique
lemma unique_runid:
	"
	All x #i #j. ( Start(x) @ i & Start(x) @ j ) ==> #i = #j
	"

//Each run ends after it starts
lemma end_after_start:
	"
	All x #j. End(x) @ j ==> Ex #i. Start(x) @ i & (#i = #j | i < j)
	"

// Only traces where Once(x) happened once
restriction once:
	"
	All x #i #j. ( Once (x) @ i & Once (x) @ j ) ==> #i = #j
	"

// -------------------- Security Lemmas ------------------------ //

lemma dbsec:
	"
	All V P ch rp #l. DBSec(V, P, ch, rp) @ l ==>
	(	//EITHER V is corrupt 	
		Ex #i. Corrupt(V) @ i & i < l
	) | 
	(	//OR P is active in fast phase
		Ex #i #j #k.
			Send(V, ch) @ i &
			Action(P) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l
	) | 
	(	//OR (P is corrupt AND there's a corrupt 
		//agent active in fast phase)
		Ex A #a #p #i #j #k.
			Corrupt(A) @ a & a < l &
			Corrupt(P) @ p & p < l &
			Send(V, ch) @ i &
			Action(A) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l
	)
	"

lemma dbsec_on_honest_prover:
	"
	All V P ch rp #l. DBSec(V, P, ch, rp) @ l ==>
		(Ex #i. Corrupt(V) @ i & i < l) |
		(Ex #i. Corrupt(P) @ i & i < l) |
		(Ex #i #j #k.
			Send(V, ch) @ i &
			Action(P) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l)
	"

lemma dbsec_on_corrupt_prover:
	"
	All V P ch rp #l. DBSec(V, P, ch, rp) @ l ==>
		(Ex #i. Corrupt(V) @ i & i < l) |
		not (Ex #i. Corrupt(P) @ i & i < l) |
		(Ex A #a #i #j #k.
			Corrupt(A) @ a & a < l &
			Send(V, ch) @ i &
			Action(A) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l)
	"
end
