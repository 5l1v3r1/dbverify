/* Implementation of TREAD (symmetric encryption version) protocol*/
/* By Jorge Toro */

theory tread_senc

begin

builtins : symmetric-encryption, asymmetric-encryption, signing 

functions: f/2, XOR/2

// -------------------- Protocol Rules -------------------- //
rule Prover1:
		let u = <~a, ~b, $P>
				w = <u, sign(u, ltkP)>
				msg = <senc(w, shk), $P>
		in	
		[ Fr(~a),
			Fr(~b),
			!Ltk($P, ltkP),
			!Shk($V, $P, shk) ]
	--[ Start(~a), Action($P) ]->
		[ Send($P, msg ),
			ProverState1($V, $P, ~a, ~b) ]

rule Verifier1:
		let u = <a, b, $P> 
				w = <u, signed>
				verify_sig = verify(signed, u, pkP) 
				msg = <senc(w, shk), $P>
		in
		[ Fr(~m), 
			In(msg),
			!Pk($P, pkP),
			!Shk($V, $P, shk) ]
	--[ Start(~m),
			Eq(verify_sig, true) ]->
		[ Out(~m),
			VerifierState1($V, $P, ~m, a, b) ]

rule Prover2:
		[ ProverState1(V, P, a, b),
			In(m) ]
	--[ Action(P) ]->
		[ ProverState2(V, P, a, b, m) ]

rule Verifier2:			//fast phase starts
		[ VerifierState1(V, P, m, a, b),
			Fr(~c) ]
	--[ Send(V, ~c) ]->
		[ Out(~c),
			VerifierState2(V, P, m, a, b, ~c) ]

rule Prover3:
		[ ProverState2(V, P, a, b, m),
			In(c) ]
	--[ Action(P),
			End(a) ]->
		[ Send(P, f(c, <a, XOR(b,m)>) ) ]

rule Verifier3:			//fast phase ends
		let resp = f(c, <a, XOR(b,m)>)
		in
		[ VerifierState2(V, P, m, a, b, c),
			Recv(V, resp ),
			!Shk(V, P, shk) ]
	--[ DBSec(V, P, c, resp),
			End(m) ]->
		[ ]

// -------------------- Reachability Lemmas ------------------ //
lemma complete_trace_exists:
	exists-trace
	"
	Ex V P a b c m #t1 #t2 #t3 #t4 #t5 #t6 #t7.
		
		//initial phase
		Start(a) @ t1 &
		Action(P) @ t1 &
		Start(m) @ t2 &		
		Action(P) @ t3 &

		//fast phase
		Send(V, c) @ t4 &
		Action(P) @ t5 &
		Recv(V, f(c, <a, XOR(b,m)>)) @ t6 &
		
		//verification
		DBSec(V, P, c, f(c, <a, XOR(b,m)>)) @ t7 &

		//check order	
		t1 < t2 & t2 < t3 & t3 < t4 & t4 < t5 & t5 < t6 & t6 < t7
	"
// -------------------- Restrictions --------------------------- //
restriction equals:
		"
		All a b #i. Eq(a,b) @ i ==> a = b
		"

//GENERIC CODE AFTER THIS LINE
//comment out whatever not needed

// ----------- Key Generation and Key Compromise -------- //
rule LtkGen:
	[ Fr(~k) ]--[ Once($X) ]->[	!Ltk($X, ~k), !Pk($X, pk(~k)), Out(pk(~k)) ]

rule ShkGen:
	[ Fr(~k) ]--[ Once(<$X, $Y>) ]->[ !Shk($X, $Y, ~k) ]

rule LtkReveal:
	[ !Ltk($X, k) ]--[ !KeyComp($X) ]->[ Out(k), !KeyComp($X) ]

rule ShkRevealX:
	[ !Shk($X, $Y, k) ]--[ !KeyComp($X) ]->[ Out(k), !KeyComp($X) ]

rule ShkRevealY:
	[ !Shk($X, $Y, k) ]--[ !KeyComp($Y) ]->[ Out(k), !KeyComp($Y) ]

// -------------- DB Network and Adversary  -------------//
rule DBAdv:
	[ In(m), !KeyComp($X) ]--[ Action($X) ]->[ Send($X, m) ]

rule DBNet:
	[ Send($X, m) ]--[ Action($Y), Recv($Y, m) ]->[ Recv($Y, m), Out(m) ]

// --------------- Sanity check & Restrictions ------------- //

// Each run id is unique
lemma unique_runid:
	"
	All x #i #j. (Start(x)@i & Start(x)@j) ==> #i=#j
	"

// Each run ends after it starts
lemma end_after_start:
	"
	All x #j. End(x)@j ==> Ex #i. Start(x)@i & (#i=#j|i<j)
	"

// Only traces where Once(x) happened once
restriction once:
	"
	All x #i #j. (Once(x)@i & Once(x)@j) ==> #i=#j
	"

/*
// Runs can always be completed
restriction completion:
	"
	All run #i. Start(run)@i ==> Ex #j. End(run)@j
	"
*/


// For each DBSec claim there was a fast phase before it
// *	Should this lemma fail, then the results for 
//		the security lemmas might be wrong
lemma no_claim_before_fastphase:
	"
	All V P chal resp #l. DBSec(V, P, chal, resp)@l ==>
		(Ex #i #j. Send(V, chal)@i & Recv(V, resp)@j & i<l & j<l)	|
		(Ex #j. !KeyComp(V)@j)		
	"


// -------------------- Security Lemmas ------------------------ //

// For each trace with a DBSec claim, it is the case
// that either the verifier is compromised, or the prover is not and he
// was active during the fast phase, or the prover is compromised and
// then there was a compromised prover active during the fast phase
lemma dbsec:
	"
	All V P chal resp #l. 
		DBSec(V, P, chal, resp)@l ==>
			(	//EITHER P is active in fast phase
				Ex #i #j #k.
					Send(V, chal)@i &
					Action(P)@j &
					Recv(V, resp)@k &
					i<j & j<k
			) | 
			(	//OR (P is compromised AND there's a compromised 
				//agent active in fast phase)
				Ex P2 #p #p2 #i #j #k.
					!KeyComp(P)@p &
					!KeyComp(P2)@p2 &
					Send(V, chal)@i &
					Action(P2)@j &
					Recv(V, resp)@k &
					i<j & j<k
			) |
			(Ex #j. !KeyComp(V)@j)
	"

// dbsec provided that prover is not compromised
// *	If this lemma fails then there's a mafia fraud
lemma dbsec_on_honest_prover:
	"
	All V P chal resp #l. 
		(DBSec(V, P, chal, resp)@l & not (Ex #j. !KeyComp(P)@j)) ==>
			(Ex #i #j #k.
				Send(V, chal)@i &
				Action(P)@j &
				Recv(V, resp)@k &
				i<j & j<k
			) |
			(Ex #j. !KeyComp(V)@j)
	"

// dbsec provided that prover is compromised
// *	If this lemma fails then there's a distance fraud,
//		or a distance hijacking, or both
lemma dbsec_on_compromised_prover:
	"
	All V P chal resp #l. 
		(DBSec(V, P, chal, resp)@l & Ex #j. !KeyComp(P)@j) ==>
			(Ex P2 #p2 #i #j #k.
				!KeyComp(P2)@p2 &
				Send(V, chal)@i &
				Action(P2)@j &
				Recv(V, resp)@k &
				i<j & j<k
			) |
			(Ex #j. !KeyComp(V)@j) 
	"
end
