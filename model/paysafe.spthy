/* Implementation of PaySafe protocol*/
/* By Jorge Toro */

theory paysafe

begin

builtins : symmetric-encryption, asymmetric-encryption, signing 

functions: MAC/4

// -------------------- Protocol Rules -------------------- //
rule Card1Constant:	
		[ Fr(~nc) ]
	--[ Start(~nc),
			Action($C) ]->
		[ Send($C, 'hello'),
			Card1($C, ~nc, 'ATC') ]

//Next is a version of the previous rule that considers ATC as a nonce
//Both rule versions yield the same results
/*rule Card1Nonce:	
		[ Fr(~nc),
			Fr(~ATC) ]
	--[ Start(~nc),
			Action($C) ]->
		[ Send($C, 'hello' ),
			Card1($C, ~nc, ~ATC) ]
*/

rule Reader1:		//fast phase starts
		[ Fr(~UN),
			Fr(~amount),
			In('hello') ]
	--[ Start(~UN),
			Send($R, < ~UN, ~amount >) ]->
		[ Out(< ~UN, ~amount >),
			Reader1($R, ~UN, ~amount) ]

rule Card2:
		[ Card1(C, nc, ATC),
			In(< UN, amount >) ]
	--[ Action(C) ]->
		[ Send(C, <ATC, nc>),
			Card2(C, nc, ATC, UN, amount) ]

rule Reader2:		//fast phase ends
		[ Reader1(R, UN, amount),
			Recv(R, <ATC, nc>) ]
	-->
		[ Reader2(R, UN, amount, ATC, nc) ]

rule Reader3:
		[ Reader2(R, UN, amount, ATC, nc) ]
	-->
		[ Out('hi'),
			Reader3(R, UN, amount, ATC, nc) ]

rule Card3:
		let KS = senc(ATC, KM)
				AC = MAC(KS, amount, ATC, UN)
				SDAD = sign(<nc, UN, AC>, ltkC) 
		in
		[ Card2(C, nc, ATC, UN, amount),
			In('hi'), 
			!Ltk(C, ltkC),
			!Shk($R, C, KM) ]
	--[ Action(C),
			End(nc) ]->
		[ Send(C, <SDAD, AC>) ]

rule Reader4:
		let KS = senc(ATC, KM)
				AC = MAC(KS, amount, ATC, UN)
				SDAD_content = <nc, UN, AC>
				verify_sig = verify(SDAD, SDAD_content, pkC)
		in 
		[ Reader3(R, UN, amount, ATC, nc),
			In(<SDAD, AC>), 
			!Pk($C, pkC),
			!Shk(R, $C, KM) ]
	--[ Eq(verify_sig, true),
			DBSec(R, $C, <UN, amount>, <ATC, nc>),
			End(UN) ]->
		[ ]

// -------------------- Reachability Lemmas ------------------ //
lemma complete_trace_exists:
	exists-trace
	"
	Ex R C nc UN amount ATC #t1 #t2 #t3 #t4 #t5 #t6.

		//initial phase
		Start(nc) @ t1 &
		Action(C) @ t1 &

		//fast phase
		Start(UN) @ t2 &
		Send(R, <UN, amount>) @ t2 &
		Action(C) @ t3 &
		Recv(R, <ATC, nc>) @ t4 &

		//verification phase
		Action(C) @ t5 &
		DBSec(R, C, <UN, amount>, <ATC, nc>) @ t6 &

		t1 < t2 & t2 < t3 & t3 < t4 & t4 < t5 & t5 < t6
	"
// -------------------- Restrictions --------------------------- //
restriction equals:
	"
	All a b #i. Eq(a,b) @ i ==> a = b
	"

//GENERIC CODE AFTER THIS LINE
//comment out whatever not needed

// ------------- Key Generation Rules -------------------- //
rule AsymKey:
	[ Fr(~k) ]--[ Once($A) ]->[ !Ltk($A, ~k), !Pk($A, pk(~k)), Out(pk(~k)) ]

rule SymKey:
	[ Fr(~k) ]--[ Once(<$A, $B>) ]->[ !Shk($A, $B, ~k) ]


// ------------------ Corruption Rules -----------//
rule LtkReveal:
	[ !Ltk($A, k) ]--[ Corrupt($A) ]->[ !CorruptAgnt($A), Out(k) ]

rule ShkRevealA:
	[ !Shk($A, $B, k) ]--[ Corrupt($A) ]->[ !CorruptAgnt($A), Out(k) ]

rule ShkRevealB:
	[ !Shk($A, $B, k) ]--[ Corrupt($B) ]->[ !CorruptAgnt($B), Out(k) ]

// ---------- Adversary and Network Rules ------------------//
rule Adv:
	[ In(m), !CorruptAgnt($A) ]--[ Action($A) ]->[ Send($A, m) ]

rule Net:
	[ Send($A, m) ]--[ Recv($B, m) ]->[ Recv($B, m), Out(m) ]

// -------------------- Sanity Check ------------------ //

//Each run id is unique
lemma unique_runid:
	"
	All x #i #j. ( Start(x) @ i & Start(x) @ j ) ==> #i = #j
	"

//Each run ends after it starts
lemma end_after_start:
	"
	All x #j. End(x) @ j ==> Ex #i. Start(x) @ i & (#i = #j | i < j)
	"

// Only traces where Once(x) happened once
restriction once:
	"
	All x #i #j. ( Once (x) @ i & Once (x) @ j ) ==> #i = #j
	"

// -------------------- Security Lemmas ------------------------ //

lemma dbsec:
	"
	All V P ch rp #l. DBSec(V, P, ch, rp) @ l ==>
	(	//EITHER V is corrupt 	
		Ex #i. Corrupt(V) @ i & i < l
	) | 
	(	//OR P is active in fast phase
		Ex #i #j #k.
			Send(V, ch) @ i &
			Action(P) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l
	) | 
	(	//OR (P is corrupt AND there's a corrupt 
		//agent active in fast phase)
		Ex A #a #p #i #j #k.
			Corrupt(A) @ a & a < l &
			Corrupt(P) @ p & p < l &
			Send(V, ch) @ i &
			Action(A) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l
	)
	"

lemma dbsec_on_honest_prover:
	"
	All V P ch rp #l. DBSec(V, P, ch, rp) @ l ==>
		(Ex #i. Corrupt(V) @ i & i < l) |
		(Ex #i. Corrupt(P) @ i & i < l) |
		(Ex #i #j #k.
			Send(V, ch) @ i &
			Action(P) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l)
	"

lemma dbsec_on_corrupt_prover:
	"
	All V P ch rp #l. DBSec(V, P, ch, rp) @ l ==>
		(Ex #i. Corrupt(V) @ i & i < l) |
		not (Ex #i. Corrupt(P) @ i & i < l) |
		(Ex A #a #i #j #k.
			Corrupt(A) @ a & a < l &
			Send(V, ch) @ i &
			Action(A) @ j &
			Recv(V, rp) @ k &
			i < j & j < k & k < l)
	"
end
